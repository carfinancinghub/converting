// File: auctionExportUtils.js
// Path: C:\CFH\frontend\src\utils\auction\auctionExportUtils.js
// Save Location: This file should be saved to C:\CFH\frontend\src\utils\auction\auctionExportUtils.js to be used by frontend components.
// Purpose: Utility for exporting auction data in PDF, CSV, and JSON formats with validation, filtering, and premium features
// Author: Rivers Auction Dev Team
// Date: 2025-05-26
// Cod2 Crown Certified: Yes

/*
## Functions Summary
| Function | Purpose | Inputs | Outputs | Dependencies |
|----------|---------|--------|---------|--------------|
| validateExportData | Validates auction data before export | `data: Array`, `selectedColumns: Array` | `true` or throws Error | `@utils/logger` |
| throttleExport | Throttles export to prevent UI freezing | `fn: Function`, `limit: Number` | Throttled function | `@utils/logger` |
| exportToPDF | Exports data to PDF | `data: Array`, `selectedColumns: Array`, `isPremium: Boolean` | `{ success: Boolean, fileName: String }` | `jspdf`, `@utils/logger` |
| exportToCSV | Exports data to CSV | `data: Array`, `selectedColumns: Array` | `{ success: Boolean, fileName: String }` | `papaparse`, `@utils/logger` |
| exportToJSON | Exports data to JSON | `data: Array`, `selectedColumns: Array` | `{ success: Boolean, fileName: String }` | `@utils/logger` |
| exportAuctionData | Main export function with throttling and premium features | `{ data: Array, format: String, selectedColumns: Array, filters: Object, isPremium: Boolean, template: Object, onProgress: Function }` | `{ success: Boolean, fileName: String }` | `jspdf`, `papaparse`, `@utils/cacheManager`, `@utils/logger` |
*/

import jsPDF from 'jspdf';
import Papa from 'papaparse';
import logger from '@utils/logger';
import { cacheManager } from '@utils/cacheManager';

// Validate auction data before export
const validateExportData = (data, selectedColumns) => {
  if (!Array.isArray(data) || data.length === 0) {
    logger.error('Invalid auction data: Empty or not an array');
    throw new Error('No auction data provided for export');
  }

  const requiredFields = ['id', 'title', 'status'];
  const missingFields = requiredFields.filter(field => !data[0].hasOwnProperty(field));
  if (missingFields.length > 0) {
    logger.error(`Missing required fields: ${missingFields.join(', ')}`);
    throw new Error(`Required fields missing: ${missingFields.join(', ')}`);
  }

  if (selectedColumns && !selectedColumns.every(col => Object.keys(data[0]).includes(col))) {
    logger.error('Invalid column selection for export');
    throw new Error('Selected columns not found in data');
  }

  return true;
};

// Throttle export to prevent UI freezing
const throttleExport = (fn, limit = 1000) => {
  let lastCall = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      return fn(...args);
    }
    logger.warn('Export throttled to prevent UI freeze');
    throw new Error('Export in progress, please wait');
  };
};

// Export to PDF
const exportToPDF = (data, selectedColumns = [], isPremium = false) => {
  try {
    validateExportData(data, selectedColumns);
    const doc = new jsPDF();
    let yOffset = 10;

    doc.text('Auction Data Export', 10, yOffset);
    yOffset += 10;

    const columns = selectedColumns.length > 0 ? selectedColumns : Object.keys(data[0]);
    data.forEach((item, index) => {
      columns.forEach(col => {
        doc.text(`${col}: ${item[col] || 'N/A'}`, 10, yOffset);
        yOffset += 10;
      });
      if (isPremium) {
        doc.text(`Generated by Premium User`, 10, yOffset);
        yOffset += 10;
      }
      yOffset += 5;
    });

    const fileName = `auction_export_${Date.now()}.pdf`;
    doc.save(fileName);
    logger.info(`PDF export successful: ${fileName}`);
    return { success: true, fileName };
  } catch (err) {
    logger.error(`PDF export failed: ${err.message}`);
    throw new Error(`Failed to export PDF: ${err.message}`);
  }
};

// Export to CSV
const exportToCSV = (data, selectedColumns = []) => {
  try {
    validateExportData(data, selectedColumns);
    const columns = selectedColumns.length > 0 ? selectedColumns : Object.keys(data[0]);
    const csvData = data.map(item => {
      const row = {};
      columns.forEach(col => {
        row[col] = item[col] || '';
      });
      return row;
    });

    const csv = Papa.unparse(csvData);
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `auction_export_${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    logger.info(`CSV export successful: ${a.download}`);
    return { success: true, fileName: a.download };
  } catch (err) {
    logger.error(`CSV export failed: ${err.message}`);
    throw new Error(`Failed to export CSV: ${err.message}`);
  }
};

// Export to JSON
const exportToJSON = (data, selectedColumns = []) => {
  try {
    validateExportData(data, selectedColumns);
    const columns = selectedColumns.length > 0 ? selectedColumns : Object.keys(data[0]);
    const jsonData = data.map(item => {
      const row = {};
      columns.forEach(col => {
        row[col] = item[col] || null;
      });
      return row;
    });

    const json = JSON.stringify(jsonData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `auction_export_${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);

    logger.info(`JSON export successful: ${a.download}`);
    return { success: true, fileName: a.download };
  } catch (err) {
    logger.error(`JSON export failed: ${err.message}`);
    throw new Error(`Failed to export JSON: ${err.message}`);
  }
};

// Main export function with throttling and premium features
const exportAuctionData = throttleExport(({
  data,
  format = 'csv',
  selectedColumns = [],
  filters = {},
  isPremium = false,
  template = null,
  onProgress = null,
}) => {
  try {
    // Apply filters
    let filteredData = data;
    if (Object.keys(filters).length > 0) {
      filteredData = data.filter(item => {
        return Object.entries(filters).every(([key, value]) => item[key] === value);
      });
    }

    // Apply template for premium users
    if (isPremium && template) {
      filteredData = filteredData.map(item => {
        const templatedItem = {};
        Object.keys(template).forEach(key => {
          templatedItem[key] = item[template[key]] || null;
        });
        return templatedItem;
      });
    }

    // Progress indicator for large datasets
    if (filteredData.length > 1000 && onProgress) {
      onProgress({ total: filteredData.length, processed: 0 });
      filteredData.forEach((_, index) => {
        if (index % 100 === 0) {
          onProgress({ total: filteredData.length, processed: index });
        }
      });
    }

    // Save user preferences
    if (isPremium) {
      cacheManager.set(`export_prefs_${data.userId || 'guest'}`, { format, selectedColumns }, { ttl: 86400 });
    }

    switch (format.toLowerCase()) {
      case 'pdf':
        return exportToPDF(filteredData, selectedColumns, isPremium);
      case 'csv':
        return exportToCSV(filteredData, selectedColumns);
      case 'json':
        return exportToJSON(filteredData, selectedColumns);
      default:
        logger.error(`Unsupported export format: ${format}`);
        throw new Error(`Unsupported format: ${format}`);
    }
  } catch (err) {
    logger.error(`Export failed: ${err.message}`);
    throw err;
  }
});

export { exportAuctionData, validateExportData };